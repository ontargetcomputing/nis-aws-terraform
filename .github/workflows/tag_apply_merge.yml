name: Apply and Release

on:
  issue_comment:
    types: [created]

jobs:
  process-comment:
    runs-on: ubuntu-latest
    if: github.event.issue.pull_request 
    outputs:
      trigger: ${{ steps.check.outputs.trigger }}
    steps:
      - name: "Check for 'action: apply' comment"
        id: check
        env:
          COMMENT_BODY: ${{ github.event.comment.body }}
        run: |
          if [[ "$COMMENT_BODY" == *"action: apply"* ]]; then
            echo "Matched comment with 'action: apply'"
            echo "::set-output name=trigger::true"
          else
            echo "::set-output name=trigger::false"
          fi

  identify_modified_workspace:
    needs: process-comment
    if: ${{ needs.process-comment.outputs.trigger == 'true' }}
    uses: ./.github/workflows/identify_modified_workspace.yml


  apply_and_merge:
    needs: 
      - process-comment
      - identify_modified_workspace
    if: ${{ needs.identify_modified_workspace.outputs.workspace_path != '' && needs.process-comment.outputs.trigger == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Debug Output
        run: |
          echo "Process Comment Trigger: ${{ needs.process-comment.outputs.trigger }}"

      - name: Get PR Branch Information
        id: pr_info
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Fetch PR details using the issue URL
          PR_URL="${{ github.event.issue.pull_request.url }}"
          PR_DETAILS=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "$PR_URL")
          
          # Extract head and base branch names
          HEAD_REF=$(echo "$PR_DETAILS" | jq -r '.head.ref')
          echo "HEAD_REF=$HEAD_REF"
          echo "head_ref=$HEAD_REF" >> "$GITHUB_OUTPUT"
                
      - name: Checkout PR Branch
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.pr_info.outputs.head_ref }}
          fetch-depth: 0

      - name: Get branch information
        run: |
          echo "Current branch: $(git branch --show-current)"
          echo "Full ref: $(git rev-parse --abbrev-ref HEAD)"
          echo "Detailed branch info:"
          git branch -vv

      - name: Parse Command
        id: parse_command
        run: |
          COMMENT="${{ github.event.comment.body }}"
          
          # Check if comment starts with 'action: apply'
          if [[ ! "$COMMENT" =~ ^action:\ apply ]]; then
            echo "Comment must start with 'action: apply'"
            exit 1
          fi
          
          # Extract version bump
          VERSION_BUMP=$(echo "$COMMENT" | grep -oP 'semver: \K(major|minor|patch)' || echo '')
          if [[ -z "$VERSION_BUMP" ]]; then
            echo "Error: Invalid or missing semver specification."
            echo "Comment must follow format:"
            echo "action: apply"
            echo "semver: [major|minor|patch]"
            echo "comment: your comment here"
            exit 1
          fi
          VERSION_BUMP=$(echo "$VERSION_BUMP" | tr '[:lower:]' '[:upper:]')
          
          # Extract comment
          COMMENT_TEXT=$(echo "$COMMENT" | grep -oP 'comment: \K(.*)$' || echo '')
          if [[ -z "$COMMENT_TEXT" ]]; then
            echo "Error: Missing comment text"
            echo "Please provide a comment describing the changes"
            exit 1
          fi
          
          echo "version_bump=$VERSION_BUMP" >> $GITHUB_OUTPUT
          echo "comment_text=$COMMENT_TEXT" >> $GITHUB_OUTPUT

      - name: Comment on Invalid Format
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ github.event.issue.number }},
              body: `‚ùå Invalid comment format. Please use:
              
              action: apply
              semver: [major|minor|patch]
              comment: your comment here`
            });

      - name: Processing
        if: success()
        run: |
          echo "Version Bump: ${{ steps.parse_command.outputs.version_bump }}"
          echo "Comment Text: ${{ steps.parse_command.outputs.comment_text }}"
          echo "Workspace: ${{ needs.identify_modified_workspace.outputs.workspace_path }}"

      - name: Determine Version Bump
        id: version_bump
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          WORKSPACE: ${{ needs.identify_modified_workspace.outputs.workspace_path }}
          VERSION_BUMP: ${{ steps.parse_command.outputs.version_bump }}
        run: |
          # Find all tags for the workspace
          WORKSPACE_TAGS=$(git ls-remote --tags origin | grep "$WORKSPACE" | awk '{print $2}' | sed 's/refs\/tags\///')
          
          # Find the highest version tag
          HIGHEST_TAG=$(echo "$WORKSPACE_TAGS" | grep "^$WORKSPACE " | sed "s/^$WORKSPACE //" | sort -V | tail -n 1)

          if [[ -z "$HIGHEST_TAG" ]]; then
              case "$VERSION_BUMP_TYPE" in
                  "major")
                      NEW_VERSION="1.0.0"
                      ;;
                  "minor")
                      NEW_VERSION="0.1.0"
                      ;;
                  "patch")
                      NEW_VERSION="0.0.1"
                      ;;
              esac
          else
            # Bump version based on type
            IFS='.' read -r major minor patch <<< "$HIGHEST_TAG"
            
            case "$VERSION_BUMP" in
              major)
                major=$((major + 1))
                minor=0
                patch=0
                ;;
              minor)
                minor=$((minor + 1))
                patch=0
                ;;
              patch)
                patch=$((patch + 1))
                ;;
              *)
                echo "Invalid bump type: $VERSION_BUMP"
                exit 1
                ;;
            esac
          fi
          
          NEW_VERSION="$major.$minor.$patch"

          # Create full new tag
          NEW_TAG="$WORKSPACE-$NEW_VERSION"

          echo "Highest existing tag: $HIGHEST_TAG"
          echo "New version: $NEW_VERSION"
          echo "New tag: $NEW_TAG"

          # Set outputs for use in subsequent steps
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT

      - name: Use Version Bump
        run: |
          echo "New Version: ${{ steps.version_bump.outputs.version }}"
          echo "New Tag: ${{ steps.version_bump.outputs.tag }}"

      # - name: Create Tag on PR Branch
      #   run: |
      #     git config user.name github-actions
      #     git config user.email github-actions@github.com
      #     git tag ${{ steps.version-bump.outputs.tag }}
      #     git push origin ${{ steps.version-bump.outputs.tag }}

      # - name: Merge PR
      #   uses: actions/github-script@v7
      #   with:
      #     github-token: ${{secrets.GITHUB_TOKEN}}
      #     script: |
      #       github.rest.pulls.merge({
      #         owner: context.repo.owner,
      #         repo: context.repo.repo,
      #         pull_number: context.issue.number
      #       })