name: Apply and Release

on:
  issue_comment:
    types: [created]

jobs:
  process-comment:
    runs-on: ubuntu-latest
    if: github.event.issue.pull_request 
    outputs:
      trigger: ${{ steps.check.outputs.trigger }}
    steps:
      - name: "Check for 'action: apply' comment"
        id: check
        env:
          COMMENT_BODY: ${{ github.event.comment.body }}
        run: |
          if [[ "$COMMENT_BODY" == *"action: apply"* ]]; then
            echo "Matched comment with 'action: apply'"
            echo "::set-output name=trigger::true"
          else
            echo "::set-output name=trigger::false"
          fi

  identify_modified_workspace:
    needs: process-comment
    if: ${{ needs.process-comment.outputs.trigger == 'true' }}
    uses: ./.github/workflows/identify_modified_workspace.yml


  apply_and_merge:
    needs: 
      - process-comment
      - identify_modified_workspace
    if: ${{ needs.identify_modified_workspace.outputs.workspace_path != '' && needs.process-comment.outputs.trigger == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Debug Output
        run: |
          echo "Process Comment Trigger: ${{ needs.process-comment.outputs.trigger }}"

      - name: Get PR Branch Information
        id: pr_info
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Fetch PR details using the issue URL
          PR_URL="${{ github.event.issue.pull_request.url }}"
          PR_DETAILS=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "$PR_URL")
          
          # Extract head and base branch names
          HEAD_REF=$(echo "$PR_DETAILS" | jq -r '.head.ref')
          echo "HEAD_REF=$HEAD_REF"
          echo "head_ref=$HEAD_REF" >> "$GITHUB_OUTPUT"
                
      - name: Checkout PR Branch
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.pr_info.outputs.head_ref }}
          fetch-depth: 0

      - name: Get branch information
        run: |
          echo "Current branch: $(git branch --show-current)"
          echo "Full ref: $(git rev-parse --abbrev-ref HEAD)"
          echo "Detailed branch info:"
          git branch -vv

      - name: Parse Command
        id: parse_command
        run: |
          COMMENT="${{ github.event.comment.body }}"
          
          # Check if comment starts with 'action: apply'
          if [[ ! "$COMMENT" =~ ^action:\ apply ]]; then
            echo "Comment must start with 'action: apply'"
            exit 1
          fi
          
          # Extract version bump
          VERSION_BUMP=$(echo "$COMMENT" | grep -oP 'semver: \K(major|minor|patch)' || echo '')
          if [[ -z "$VERSION_BUMP" ]]; then
            echo "Error: Invalid or missing semver specification."
            echo "Comment must follow format:"
            echo "action: apply"
            echo "semver: [major|minor|patch]"
            echo "comment: your comment here"
            exit 1
          fi
          VERSION_BUMP=$(echo "$VERSION_BUMP" | tr '[:lower:]' '[:upper:]')
          
          # Extract comment
          COMMENT_TEXT=$(echo "$COMMENT" | grep -oP 'comment: \K(.*)$' || echo '')
          if [[ -z "$COMMENT_TEXT" ]]; then
            echo "Error: Missing comment text"
            echo "Please provide a comment describing the changes"
            exit 1
          fi
          
          echo "version_bump=$VERSION_BUMP" >> $GITHUB_OUTPUT
          echo "comment_text=$COMMENT_TEXT" >> $GITHUB_OUTPUT

      - name: Comment on Invalid Format
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ github.event.issue.number }},
              body: `❌ Invalid comment format. Please use:
              
              action: apply
              semver: [major|minor|patch]
              comment: your comment here`
            });

      - name: Processing
        if: success()
        run: |
          echo "Version Bump: ${{ steps.parse_command.outputs.version_bump }}"
          echo "Comment Text: ${{ steps.parse_command.outputs.comment_text }}"
          echo "Workspace: ${{ needs.identify_modified_workspace.outputs.workspace_path }}"

      - name: Determine Version Bump
        id: version_bump
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          WORKSPACE: ${{ needs.identify_modified_workspace.outputs.workspace_path }}
          VERSION_BUMP: ${{ steps.parse_command.outputs.version_bump }}
        run: |
          WORKSPACE_TAGS=$(git ls-remote --tags origin | grep "${WORKSPACE}" | awk '{print $2}' | sed 's|refs/tags/||')
          HIGHEST_TAG=$(echo "$WORKSPACE_TAGS" | grep "^${WORKSPACE}-" | awk -F "${WORKSPACE}-" '{print $2}' | sort -V | tail -n 1)


          # If no tag exists, start at 0.0.1
          if [[ -z "$HIGHEST_TAG" ]]; then
              case "$VERSION_BUMP" in
                  "MAJOR")
                      NEW_VERSION="1.0.0"
                      ;;
                  "MINOR")
                      NEW_VERSION="0.1.0"
                      ;;
                  "PATCH")
                      NEW_VERSION="0.0.1"
                      ;;
              esac
          else
              # Split version into components
              MAJOR=$(echo "$HIGHEST_TAG" | cut -d. -f1)
              MINOR=$(echo "$HIGHEST_TAG" | cut -d. -f2)
              PATCH=$(echo "$HIGHEST_TAG" | cut -d. -f3)

              # Bump version according to type
              case "$VERSION_BUMP_TYPE" in
                  "MAJOR")
                      MAJOR=$((MAJOR + 1))
                      MINOR=0
                      PATCH=0
                      ;;
                  "MINOR")
                      MINOR=$((MINOR + 1))
                      PATCH=0
                      ;;
                  "PATCH")
                      PATCH=$((PATCH + 1))
                      ;;
              esac

              NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          fi

          # Create full new tag
          NEW_TAG="$WORKSPACE-$NEW_VERSION"

          echo "Highest existing tag: $HIGHEST_TAG"
          echo "New version: $NEW_VERSION"
          echo "New tag: $NEW_TAG"

          # Set outputs for use in subsequent steps
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT

      - name: Use Version Bump
        run: |
          echo "New Version: ${{ steps.version_bump.outputs.version }}"
          echo "New Tag: ${{ steps.version_bump.outputs.tag }}"

      - name: Create Tag on PR Branch
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
          git tag ${{ steps.version_bump.outputs.tag }}
          git push origin ${{ steps.version_bump.outputs.tag }}

      - name: Merge PR with Squash
        uses: actions/github-script@v7
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            const { data: pullRequest } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            // Create a commit message that includes the PR title and body
            const commitMessage = `${pullRequest.title}\n\n${pullRequest.body || ''}\n\nComment: ${{ steps.parse_command.outputs.comment_text }}\n\nCloses #${context.issue.number}`;

            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              merge_method: 'squash',
              commit_title: commitMessage
            });